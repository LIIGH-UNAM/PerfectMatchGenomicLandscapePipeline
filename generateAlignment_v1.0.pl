#!/usr/bin/perl -w

#use strict;
use LWP::Simple;
use File::Copy;
use Getopt::Long;
use FindBin qw( $RealBin );
require "${RealBin}/library.pm";

#print "arg\n";
my $arg = $ARGV[0];
if (!$arg){
 $arg = '';
}

if ($arg eq "-h" || $arg eq "-help") {
    open HELP, "| more";
    print HELP <<End_of_Help;
###
### AUTHOR : 
###     Jair Santiago Garcia Sotelo, send comments to jsgarcia\@liigh.unam.mx
###     Kim Palacios Flores, send comments to kimpalaciosflores\@gmail.com
###
### NAME : generateAligment_v1.0.pl 
###
### VERSION : version 1.0
###
### DESCRIPTION : For each signature of variation located using the zero-trail scan, generates an alignment anchored by the Downstream Recovery String. 
###   
### OUTPUT : Generates four types of output:
### 1) The Query Genome sequence reads containing a perfect match with the Downstream Recovery String. 
### 2) The different Query Genome sequences (Read Families) that contain a perfect match with the Downstream Recovery String, and that have a minimum number of 
###     occurrences in the Query Genome.
### 3) The alignment files generated by the MUSCLE Multiple Sequence Alignment tool.
### 4) Alignment files in fasta format.
###     
###
### USAGE : perl generateAligment_v1.0.pl -binDir /url/ -outputDir /url/ -zeroTrailScanFile PMGL#_RG#_all_PMnCR_SV_ZeroTrailScan.tab -rgslFile /URL/RGSL#.tab -fastqFile /url/QG#.fastq -rawRgDir /url/ -rgId RG# -minCountFamily # -memory # -kmerLength # -maxFamily #
###      
### OPTIONS :
###   -binDir : Path of directory containing all PMGL pipeline scripts.
###   -outputDir : Path of output directory.
###   -rawRgDir : Path of directory containing the raw RG sequence per chromosome in txt format. 
###         The files contained in rawRgDir require the following nomenclature: RG#_#.txt (The first # indicates the numeric component 
###         of the RG unqiue identifier, the second # indicates the chromosome number). Each file must contain a single line with the 
###         chromosome sequence only. 
###   -zeroTrailScanFile : File containing the signatures of variation located using the zero-trail scan.
###   -rgslFile : Path of file containing the RGSL.
###   -fastqFile : Path of file containing the Query Genome sequence reads in a single fastq file. 
###   -rgId : Reference Genome unique identifier.
###   -minCountFamily : Minimum number of identical cut reads per Family.
###   -memory : RAM memory to be used for jellyfish execution.
###   -kmerLength : Length of kmer.
###   -maxFamily : Maximum number of different Read Families.
###   -h or -help
###   
### DATE : 01/10/2017
###
### Requirements : 
### 1)
###   Perl's  Libraries
###     Getopt::Long;
###
###
End_of_Help
    close HELP;
    exit(0);
}

my %opts;

### Parameters
GetOptions (\%opts,
    'binDir=s', 
    'outputDir=s', 
    'zeroTrailScanFile=s', 
    'rgslFile=s', 
    'fastqFile=s', 
    'rawRgDir=s', 
    'rgId=s', 
    'minCountFamily=s', 
    'memory=s', 
    'kmerLength=i', 
    'maxFamily=s'
    );

&readArguments();
my $zeroTrailScanFile =  $opts{zeroTrailScanFile};
my $rgslFile =  $opts{rgslFile};
my $fastqFile =  $opts{fastqFile};
my $rawRgDir =  $opts{rawRgDir};
my $binDir =  $opts{binDir};
my $rgId =  $opts{rgId};
my $outputDir =  $opts{outputDir};
my $minCountFamily = $opts{minCountFamily};
my $memory = $opts{memory};
my $kmerLength = $opts{kmerLength};
my $maxFamily =  $opts{maxFamily};

my @structura;

&main();


sub main {

    my $bashDir = $outputDir."bash/";
    my $readsDir = $outputDir."reads/";
    my $familyDir = $outputDir."family/";
    my $muscleDir = $outputDir."muscle/";
    my $alignmentDir = $outputDir."alignment/";

    system ("rm -rf ${bashDir}");
    system ("rm -rf ${readsDir}");
    system ("rm -rf ${familyDir}");
    system ("rm -rf ${muscleDir}");
    system ("rm -rf ${alignmentDir}");

    mkdir $bashDir;
    mkdir $readsDir;
    mkdir $familyDir;
    mkdir $muscleDir;
    mkdir $alignmentDir;

print "\nGenerating bash: search of Query Genome sequence reads\n";

    my $numberWalk = 1;   

    my @structurezeroTrailScanFile;
    open(IN, $zeroTrailScanFile) or die("Can't read ${zeroTrailScanFile} file");
        @structurezeroTrailScanFile = <IN>;
    close(IN);


    open(OUTPUT_FILE_ALIGNMENT, "> ${bashDir}${rgId}_alignment.bash") or die("Can't create file");
    foreach my $structurezeroTrailScanFileIndex (0 .. $#structurezeroTrailScanFile) {
        my $currentLine = $structurezeroTrailScanFile[$structurezeroTrailScanFileIndex];
        chop $currentLine;
        if ($currentLine !~ /^#/) {
            my @currentLineArray = split("\t", $currentLine);
            $currentLineArray[0] =~ /.*_(\d+)_\d+/; 
            my $chromosome = $1;
            my $seqQueryAdd = "";
            print OUTPUT_FILE_ALIGNMENT "bash ${binDir}findReads_v1.0.sh $currentLineArray[2] ${fastqFile} ".$currentLineArray[0]." ${rgslFile} ${rawRgDir}${rgId}_".$chromosome.".txt ${readsDir} ${familyDir} ${binDir} ${minCountFamily} ${alignmentDir} ${kmerLength} ${numberWalk} ${maxFamily} ${seqQueryAdd} \n";
        }
    }
    close(OUTPUT_FILE_ALIGNMENT);
##}

   
print "\nExecuting bash: search of Query Genome sequence reads\n";

    my $numberZeroTrailScan = &numberOfLines(${zeroTrailScanFile});


    system ("perl ${binDir}makeSGE_v1.0.pl -i ${bashDir}${rgId}_alignment.bash -memory ${memory} ");

    print "\tExecuting JOB in cluster \n";
    my $qsubOrderFamily = `qsub -t 1-${numberZeroTrailScan}:1 ${bashDir}${rgId}_alignment.sge`;

    $qsubOrderFamily =~ /Your job-array (\d+)\.\d+-\d+:\d+ \(\"${rgId}_alignment\"\) has been submitted/;
    $qsubOrderFamily = $1;

    &waitingForTheCluster($qsubOrderFamily);

### Executing MUSCLE tools
print "\nExecuting MUSCLE tools\n";

    my @familyFileArray;

    opendir(my $familyDirIndex, $familyDir) || die "Error :( $! \n"; 
    while(readdir $familyDirIndex){ 
        if (-f $familyDir . "/" . $_) {
            if ($_ =~ /.*_F\d\.fasta/) {
                     push (@familyFileArray, $_);
            }
        } 
    }
    closedir $familyDirIndex;   

    for (my $familyFileArrayIndex = 0; $familyFileArrayIndex < @familyFileArray;  $familyFileArrayIndex++) {

        print "\nFile: ".$familyFileArray[$familyFileArrayIndex]."\n";

        system ("perl ${binDir}muscle_lwp.pl ${familyDir}$familyFileArray[$familyFileArrayIndex] --email jsgarciasotelo\@gmail.com --outfile ${muscleDir}$familyFileArray[$familyFileArrayIndex]");

        if (! -f $muscleDir.$familyFileArray[$familyFileArrayIndex].".aln-clustalw.clw"){
            $familyFileArrayIndex --;
        }
    }

### Formatting alignment files
print "\nFormatting alignment files\n";

    my @muscleFileArray;

    opendir(my $muscleDirIndex, ${muscleDir}) || die "Error :( $! \n";  
    while(readdir $muscleDirIndex){  
        if (-f ${muscleDir} . "/" . $_) { 
            if ($_ =~ /.*\.aln-clustalw\.clw/) { 
                     push (@muscleFileArray, $_); 
            }
        } 
    }
    closedir $muscleDirIndex; 

    &cutAlignment($muscleDir, $alignmentDir, @muscleFileArray);
}


### Read arguments
sub readArguments {
        my $mandatoryParameters = 'true';
        if (!$opts{zeroTrailScanFile}){
                $opts{zeroTrailScanFile} = '';
        }
        if (!$opts{rgslFile}){
                $opts{rgslFile} = '';
        }
        if (!$opts{fastqFile}){
                $opts{fastqFile} = '';
        }
        if (!$opts{rawRgDir}){
                $opts{rawRgDir} = '';
        }
        if (!$opts{binDir}){
                $opts{binDir} = '';
        }
        if (!$opts{rgId}){
                $opts{rgId} = '';
        }
        if (!$opts{outputDir}){
                $opts{outputDir} = '';
        }
        if (!$opts{minCountFamily}){
            $opts{minCountFamily} = '';
        }
        if (!$opts{memory}){
            $opts{memory} = '';
        }
        if (!$opts{kmerLength}){
            $opts{kmerLength} = '';
        }
        if (!$opts{maxFamily}){
            $opts{maxFamily} = '';
        }

        ### Mandatory parameters
        if ($opts{zeroTrailScanFile} eq ''){
                print ("Needs the -zeroTrailScanFile parameter \n");
                $mandatoryParameters = 'false';
        }elsif (! -f $opts{zeroTrailScanFile}){
            print ("\t-zeroTrailScanFile File does not exist: $opts{zeroTrailScanFile}\n");
            $mandatoryParameters = 'false';
        }elsif ($opts{zeroTrailScanFile} !~ /PMGL\d+_RG\d+_all_PMnCR_SV_ZeroTrailScan.*/){
            print ("\t-zeroTrailScanFile Required the following nomenclature: PMGL#_RG#_all_PMnCR_SV_ZeroTrailScan.tab \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{rgslFile} eq ''){
                print ("Needs the -rgslFile parameter \n");
                $mandatoryParameters = 'false';
        }elsif (! -f $opts{rgslFile}){
            print ("\t-rgslFile File does not exist: $opts{rgslFile}\n");
            $mandatoryParameters = 'false';
        }elsif ($opts{rgslFile} !~ /RGSL\d+\.tab$/){
            print ("\t-rgslFile Required the following nomenclature: RGSL#.tab \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{fastqFile} eq ''){
                print ("Needs the -fastqFile parameter \n");
                $mandatoryParameters = 'false';
        }elsif (! -f $opts{fastqFile}){
            print ("\t-fastqFile File does not exist: $opts{fastqFile}\n");
            $mandatoryParameters = 'false';
        }elsif ($opts{fastqFile} !~ /QG\d+\.fastq$/){
            print ("\t-fastqFile Required the following nomenclature: QG#.fastq \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{rawRgDir} eq ''){
                print ("Needs the -rawRgDir parameter \n");
                $mandatoryParameters = 'false';
        }elsif (! -d $opts{rawRgDir}){
            print ("\t-rawRgDir Directory does not exist: $opts{rawRgDir}\n");
            $mandatoryParameters = 'false';
        }

        if ($opts{binDir} eq ''){
                print ("Needs the -binDir parameter \n");
                $mandatoryParameters = 'false';
        }elsif (! -d $opts{binDir}){
            print ("\t-binDir Directory does not exist: $opts{binDir}\n");
            $mandatoryParameters = 'false';
        }

        if ($opts{rgId} eq ''){
                print ("Needs the -rgId parameter \n");
                $mandatoryParameters = 'false';
        }elsif($opts{rgId} !~ /^RG\d+$/){
            print ("\t-rgId Required the following nomenclature: RG# \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{outputDir} eq ''){
                print ("Needs the -outputDir parameter \n");
                $mandatoryParameters = 'false';
        }elsif (! -d $opts{outputDir}){
            print ("\t-outputDir Directory does not exist: $opts{outputDir}\n");
            $mandatoryParameters = 'false';
        }

        if ($opts{minCountFamily} eq ''){
            print ("Needs the -minCountFamily parameter \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{memory} eq ''){
            print ("Needs the -memory parameter \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{kmerLength} eq ''){
            print ("Needs the -kmerLength parameter \n");
            $mandatoryParameters = 'false';
        }

        if ($opts{maxFamily} eq ''){
            print ("Needs the -maxFamily parameter \n");
            $mandatoryParameters = 'false';
        }

        if ($mandatoryParameters eq 'false'){
                exit(0);
        }
}



